## Key Decisions (коротко)

### 1) Мультитенантность через Catalog DB + Project DB
**Зачем:** изоляция данных и доступов по проектам, разные сроки хранения/нагрузка.  
**Как:** каталог хранит проекты/DSN и “глобальную” конфигурацию UID; projectSlug маршрутизирует запросы и выбирает БД.  
**Компромисс:** сложнее миграции и управление коннектами → нужен connection manager.

### 2) UID-based конфигурация
**Зачем:** повторно использовать конфигурацию типа станции (теги/правила/карточки) и не дублировать по проектам.  
**Как:** станция шлет UUID → UID Router определяет UID → конфигурация подтягивается из каталога.  
**Компромисс:** строгая дисциплина версий схем/правил → нужен контроль изменений и тестовые сценарии.

### 3) TCP ingest отделен от HTTP/WebSocket
**Зачем:** разные профили нагрузки и отказоустойчивость: ingest не должен зависеть от UI/HTTP.  
**Как:** TCP сервис живет отдельным модулем и пишет в БД; WebSocket берет данные из того же контура.  
**Компромисс:** больше внутренней координации (события/состояния).

### 4) Декодирование пакетов “по схеме” из БД
**Зачем:** станции меняются/разные версии → схема в каталоге позволяет обновлять без перекомпиляции.  
**Как:** offset/len/scale/precision + bit_offset для bool; реестр декодеров для расширения.  
**Компромисс:** нужно тщательно валидировать схемы и иметь эмуляторы пакетов.

### 5) Аварии как состояние (stateful), а не “одиночные события”
**Зачем:** избежать флаппинга, корректно открывать/закрывать аварии, группировать.  
**Как:** state tracker + обработчик правил; события пишутся в журнал и пушатся по WS.  
**Компромисс:** сложнее логика и тестирование → обязательны сценарные тесты.


